#include "executablesignature_linux.h"

#include <codecvt>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>
#include <iostream>
#include <sstream>
#include <openssl/pem.h>
#include <openssl/rsa.h>
#include <openssl/sha.h>
#include <openssl/bio.h>

#include "boost/filesystem/path.hpp"

#include "executable_signature.h"

// key_pub.txt is generated by build_all.py from key.pub
// The syntax used in key_pub.txt utilizes the raw string literals feature of the C++11 standard.
// - https://www.stroustrup.com/C++11FAQ.html#raw-strings
const char* g_PublicKeyData =
#include "../../../common/keys/linux/key_pub.txt"
;

// Buffer for file read operations. The buffer must be able to accomodate
// the RSA signature in whole (e.g. 4096-bit RSA key produces 512 byte signa
#define BUFFER_SIZE 512
static unsigned char buffer[BUFFER_SIZE];

class EvpBioCharBuf
{
public:
   EvpBioCharBuf(void);
   ~EvpBioCharBuf(void);

   bool isValid(void) const { return pBIO_ != NULL; }
   BIO* getBIO() const { return pBIO_; }
   int write(const void *data, int dlen);

private:
   BIO* pBIO_;
};

EvpBioCharBuf::EvpBioCharBuf(void)
{
   pBIO_ = BIO_new(BIO_s_mem());
}

EvpBioCharBuf::~EvpBioCharBuf(void)
{
   if (pBIO_ != NULL) {
      BIO_free_all(pBIO_);
   }
}

int EvpBioCharBuf::write(const void *data, int dlen)
{
    if (pBIO_ != NULL) {
        return BIO_write(pBIO_, data, dlen);
    }

    return 0;
}

ExecutableSignaturePrivate::ExecutableSignaturePrivate(ExecutableSignature* const q) : ExecutableSignaturePrivateBase(q)
{
}

ExecutableSignaturePrivate::~ExecutableSignaturePrivate()
{
}

bool ExecutableSignaturePrivate::verify(const std::string& exePath)
{
    std::string pubKeyBytes(g_PublicKeyData);

    // key.pub is 800 bytes on disk
    if (pubKeyBytes.size() > 800)
    {
        lastError_ << "Invalid public key, size is too large: " << pubKeyBytes.size() << " bytes";
        return false;
    }

    // read public key into openssl bio abstraction
    EvpBioCharBuf bioPublicKey;
    if (!bioPublicKey.isValid())
    {
        lastError_ << "Failed to allocate an OpenSSL BIO buffer";
        return false;
    }

    if (bioPublicKey.write(pubKeyBytes.data(), pubKeyBytes.length()) <= 0)
    {
        lastError_ << "Failed to write public key resource to bio";
        return false;
    }

    // Calculate SHA256 digest for datafile
    FILE* datafile = fopen(exePath.c_str() , "rb");
    if (datafile == NULL)
    {
        lastError_ << "Failed to open executable for reading: " << errno;
        return false;
    }

    // Buffer to hold the calculated digest
    unsigned char digest[SHA256_DIGEST_LENGTH];
    SHA256_CTX ctx;
    SHA256_Init(&ctx);

    // Read binary data in chunks and feed it to OpenSSL SHA256
    unsigned bytes = 0;
    while ((bytes = fread(buffer, 1, BUFFER_SIZE, datafile)))
    {
        SHA256_Update(&ctx, buffer, bytes);
    }
    SHA256_Final(digest, &ctx);
    fclose(datafile);

    boost::filesystem::path path(exePath);
    std::ostringstream stream;
    stream << path.parent_path().native() << "/signatures/" << path.stem().native() << ".sig";
    std::string sigFile = stream.str();

    // Read signature from file
    FILE* sign = fopen(sigFile.c_str() , "r");
    if (sign == NULL)
    {
        lastError_ << "Failed to open signature file (" << sigFile << ") for reading: " << errno;
        return false;
    }

    bytes = fread(buffer, 1, BUFFER_SIZE, sign);
    fclose(sign);

    if (bytes != BUFFER_SIZE)
    {
        lastError_ << "Signature file is an invalid size, or failed to read entire file. Expected " << BUFFER_SIZE << L" bytes, read " << bytes << ".";
        return false;
    }

    // Verify that calculated digest and signature match
    RSA* rsa_pubkey = PEM_read_bio_RSA_PUBKEY(bioPublicKey.getBIO(), NULL, NULL, NULL);
    if (rsa_pubkey == NULL)
    {
        lastError_ << "Failed to read the RSA public key";
        return false;
    }

    // Decrypt signature (in buffer) and verify it matches
    // with the digest calculated from data file.
    int result = RSA_verify(NID_sha256, digest, SHA256_DIGEST_LENGTH, buffer, bytes, rsa_pubkey);
    RSA_free(rsa_pubkey);

    if (result != 1) {
        lastError_ << "Executable's signature does not match signature file";
    }

    return (result == 1);
}

bool ExecutableSignaturePrivate::verify(const std::wstring& exePath)
{
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
    std::string converted = converter.to_bytes(exePath);
    return verify(converted);
}
