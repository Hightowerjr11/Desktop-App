#include "firewallcontroller_mac.h"
#include <QStandardPaths>
#include "utils/logger.h"
#include <QDir>
#include <QCoreApplication>

FirewallController_mac::FirewallController_mac(QObject *parent, IHelper *helper) :
    FirewallController(parent), forceUpdateInterfaceToSkip_(false)
{
    helper_ = dynamic_cast<Helper_mac *>(helper);
}

FirewallController_mac::~FirewallController_mac()
{

}

bool FirewallController_mac::firewallOn(const QString &ip, bool bAllowLanTraffic)
{
    QMutexLocker locker(&mutex_);

    /*if (!bInitialized_)
    {
        latestEnabledState_ = firewallActualState();
        bInitialized_ = true;

        if (latestEnabledState_ == true)
        {

        }
        else
        {

        }
    }*/

    FirewallController::firewallOn(ip, bAllowLanTraffic);
    if (isStateChanged())
    {
        qCDebug(LOG_FIREWALL_CONTROLLER) << "firewall changed with ips count:" << countIps(ip);
        return firewallOnImpl(ip, bAllowLanTraffic, latestStaticIpPorts_);
    }
    else if (forceUpdateInterfaceToSkip_)
    {
        qCDebug(LOG_FIREWALL_CONTROLLER) << "firewall changed due to interface-to-skip update";
        return firewallOnImpl(ip, bAllowLanTraffic, latestStaticIpPorts_);
    }
    else
    {
        return true;
    }
}

bool FirewallController_mac::firewallOff()
{
    QMutexLocker locker(&mutex_);
    FirewallController::firewallOff();
    if (isStateChanged())
    {
        //restore settings
        QString str = helper_->executeRootCommand("pfctl -v -f /etc/pf.conf");
        qCDebug(LOG_FIREWALL_CONTROLLER) << "Output from pfctl -v -f /etc/pf.conf command: " << str;
        str = helper_->executeRootCommand("pfctl -d");
        qCDebug(LOG_FIREWALL_CONTROLLER) << "Output from disable firewall command: " << str;

        // force delete the table "windscribe_ips"
        str = helper_->executeRootCommand("pfctl -t windscribe_ips -T kill");

        str = helper_->executeRootCommand("pfctl -si");
        qCDebug(LOG_FIREWALL_CONTROLLER) << "Output from status firewall command: " << str;

        qCDebug(LOG_FIREWALL_CONTROLLER) << "firewallOff disabled";

        return true;
    }
    else
    {
        return true;
    }
}

bool FirewallController_mac::firewallActualState()
{
    QMutexLocker locker(&mutex_);
    if (helper_->currentState() != IHelper::STATE_CONNECTED)
    {
        Q_ASSERT(false);
        qCDebug(LOG_FIREWALL_CONTROLLER) << "FATAL error: helper state is not connected";
        return false;
    }

    // Additionally check the table "windscribe_ips", which will indicate that the firewall is enabled by our program.
    QString tableReport = helper_->executeRootCommand("pfctl -t windscribe_ips -T show");
    QString report = helper_->executeRootCommand("pfctl -si");
    if (report.indexOf("Status: Enabled") != -1)
    {
        if (tableReport.isEmpty())
        {
            qCDebug(LOG_FIREWALL_CONTROLLER) << "FATAL error: firewall enabled, but windscribe_ips table doesn't exist. Probably 3rd party software intervention.";
        }

        return true;
    }
    else
    {
        if (!tableReport.isEmpty())
        {
            qCDebug(LOG_FIREWALL_CONTROLLER) << "FATAL error: firewall disabled, but windscribe_ips table exists.";
        }
        return false;
    }
}

bool FirewallController_mac::whitelistPorts(const types::StaticIpPortsVector &ports)
{
    QMutexLocker locker(&mutex_);
    FirewallController::whitelistPorts(ports);
    if (isStateChanged() && latestEnabledState_)
    {
        return firewallOnImpl(latestIp_, latestAllowLanTraffic_, ports);
    }
    else
    {
        return true;
    }
}

bool FirewallController_mac::deleteWhitelistPorts()
{
    return whitelistPorts(types::StaticIpPortsVector());
}

bool FirewallController_mac::firewallOnImpl(const QString &ip, bool bAllowLanTraffic, const types::StaticIpPortsVector &ports )
{
    QString pfConfigFilePath = QStandardPaths::writableLocation(QStandardPaths::AppLocalDataLocation);
    QDir dir(pfConfigFilePath);
    dir.mkpath(pfConfigFilePath);
    pfConfigFilePath += "/pf.conf";
    qCDebug(LOG_BASIC) << pfConfigFilePath;

    forceUpdateInterfaceToSkip_ = false;

    QString pf = "";
    pf += "# Automatically generated by Windscribe. Any manual change will be overridden.\n";
    pf += "set block-policy return\n";


    pf += "set skip on { lo0}\n";


    //if (!interfaceToSkip_.isEmpty())
    {
        //pf += "pass out quick on utun420 inet from any to any\n";
        //pf += "pass in quick on utun420 inet from any to any\n";
    }

    pf += "scrub in all\n"; // 2.9

    // Drop everything that doesn't match a rule
    pf += "block all\n";

    QString ips =ip;
    ips = ips.replace(";", " ");
    pf += "table <windscribe_ips> persist { " + ips + " }\n";

    // allow traffic on VPN interface
    if (!interfaceToSkip_.isEmpty())
    {
        pf += "pass out quick on " + interfaceToSkip_ + " inet from any to any\n";
        pf += "pass in quick on " + interfaceToSkip_ + " inet from any to any\n";
    }

    // Allow Dynamic Host Configuration Protocol (DHCP)
    pf += "pass out quick inet proto udp from 0.0.0.0 to 255.255.255.255 port = 67\n";
    pf += "pass in quick proto udp from any to any port = 68\n";

    pf += "pass out quick inet from any to <windscribe_ips>\n";
    pf += "pass in quick inet from any to <windscribe_ips>\n";

    if (!ports.isEmpty())
    {
        //pass in proto tcp from any to any port 1234
        for (unsigned int port : ports)
        {
            pf += "pass in quick proto tcp from any to any port = " + QString::number(port) + "\n";
        }
    }


    if (bAllowLanTraffic)
    {
        pf += "anchor lan_traffic all {\n";
        const QStringList rules = lanTrafficRules();
        for (auto &r : rules)
        {
            pf += r + "\n";
        }
        pf += "}\n";
    }
    else
    {
        pf += "anchor lan_traffic all\n";
    }


    QFile f(pfConfigFilePath);
    if (f.open(QIODevice::WriteOnly))
    {
        QTextStream ts(&f);
        ts << pf;
        f.close();

        // Note:
        // Be careful adding '-F all' to this command to fix an issue.  Adding it will prevent the
        // OpenVPN over TCP and Stealth protocols from completing their connection setup.

        QString reply = helper_->executeRootCommand("pfctl -v -f \"" + pfConfigFilePath + "\"");
        //qCDebug(LOG_FIREWALL_CONTROLLER) << "Firewall on pfctl result:" << reply;
        Q_UNUSED(reply);

        helper_->executeRootCommand("pfctl -e");

        return true;
    }
    else
    {
        return false;
    }
}

QStringList FirewallController_mac::basicRules() const
{
    QStringList rules;

    rules << "set block-policy return";
    rules << "set skip on { lo0 }";
    rules << "scrub in all";
    rules << "block all";
    rules << "table <windscribe_ips> persist";
    rules << "anchor vpn_traffic all";

    // Allow Dynamic Host Configuration Protocol (DHCP)
    rules << "pass out quick inet proto udp from 0.0.0.0 to 255.255.255.255 port = 67\n";
    rules << "pass in quick proto udp from any to any port = 68\n";

    rules << "pass out quick inet from any to <windscribe_ips>\n";
    rules << "pass in quick inet from <windscribe_ips> to any\n";


    //if (!interfaceToSkip_.isEmpty())
    //{
        //pf += "pass out quick on utun420 inet from any to any\n";
        //pf += "pass in quick on utun420 inet from any to any\n";
    //}


    // Drop everything that doesn't match a rule


    //QString ips =ip;
    //ips = ips.replace(";", " ");
    //pf += "table <windscribe_ips> persist { " + ips + " }\n";

    // allow traffic on VPN interface
    /*if (!interfaceToSkip_.isEmpty())
    {
        pf += "pass out quick on " + interfaceToSkip_ + " inet from any to any\n";
        pf += "pass in quick on " + interfaceToSkip_ + " inet from any to any\n";
    }


    if (!ports.isEmpty())
    {
        //pass in proto tcp from any to any port 1234
        for (unsigned int port : ports)
        {
            pf += "pass in quick proto tcp from any to any port = " + QString::number(port) + "\n";
        }
    }*/


    /*if (bAllowLanTraffic)
    {
        pf += "anchor lan_traffic all {\n";
        const QStringList rules = lanTrafficRules();
        for (auto &r : rules)
        {
            pf += r + "\n";
        }
        pf += "}\n";
    }
    else
    {
        pf += "anchor lan_traffic all\n";
    }*/

}

QStringList FirewallController_mac::lanTrafficRules() const
{
    QStringList rules;
    // Local Network
    rules << "pass out quick inet from any to 192.168.0.0/16";
    rules << "pass in quick inet from 192.168.0.0/16 to any";
    rules << "pass out quick inet from any to 172.16.0.0/12";
    rules << "pass in quick inet from 172.16.0.0/12 to any";
    rules << "pass out quick inet from any to 169.254.0.0/16";
    rules << "pass in quick inet from 169.254.0.0/16 to any";
    rules << "block out quick inet from any to 10.255.255.0/24";
    rules << "block in quick inet from 10.255.255.0/24 to any";
    rules << "pass out quick inet from any to 10.0.0.0/8";
    rules << "pass in quick inet from 10.0.0.0/8 to any";

    // Loopback addresses to the local host
    rules << "pass in quick inet from 127.0.0.0/8 to any";

    // Multicast addresses
    rules << "pass in quick inet from 224.0.0.0/4 to any";

    // Allow AirDrop
    rules << "pass in quick on awdl0 inet6 proto udp from any to any port = 5353";
    rules << "pass out quick on awdl0 proto tcp all flags any";

    // UPnP
    rules << "pass out quick inet proto udp from any to any port = 1900";
    rules << "pass in quick proto udp from any to any port = 1900";
    rules << "pass out quick inet proto udp from any to any port = 1901";
    rules << "pass in quick proto udp from any to any port = 1901";

    rules << "pass out quick inet proto udp from any to any port = 5350";
    rules << "pass in quick proto udp from any to any port = 5350";
    rules << "pass out quick inet proto udp from any to any port = 5351";
    rules << "pass in quick proto udp from any to any port = 5351";
    rules << "pass out quick inet proto udp from any to any port = 5353";
    rules << "pass in quick proto udp from any to any port = 5353";
    return rules;
}

void FirewallController_mac::setInterfaceToSkip_posix(const QString &interfaceToSkip)
{
    QMutexLocker locker(&mutex_);
    qCDebug(LOG_BASIC) << "FirewallController_mac::setInterfaceToSkip_posix ->" << interfaceToSkip;
    if (interfaceToSkip_ != interfaceToSkip) {
        interfaceToSkip_ = interfaceToSkip;
        forceUpdateInterfaceToSkip_ = true;
    }
}

void FirewallController_mac::enableFirewallOnBoot(bool bEnable)
{
    qCDebug(LOG_BASIC) << "Enable firewall on boot, bEnable =" << bEnable;
    QString strTempFilePath = QString::fromLocal8Bit(getenv("TMPDIR")) + "windscribetemp.plist";
    QString filePath = "/Library/LaunchDaemons/com.aaa.windscribe.firewall_on.plist";

    QString pfConfFilePath = QStandardPaths::writableLocation(QStandardPaths::AppLocalDataLocation);
    QString pfBashScriptFile = pfConfFilePath + "/windscribe_pf.sh";
    pfConfFilePath = pfConfFilePath + "/pf.conf";

    if (bEnable)
    {
        //create bash script
        {
            QString exePath = QCoreApplication::applicationFilePath();
            QFile file(pfBashScriptFile);
            if (file.open(QIODevice::WriteOnly | QIODevice::Text))
            {
                file.resize(0);
                QTextStream in(&file);
                in << "#!/bin/bash\n";
                in << "FILE=\"" << exePath << "\"\n";
                in << "if [ ! -f \"$FILE\" ]\n";
                in << "then\n";
                in << "echo \"File $FILE does not exists\"\n";
                in << "launchctl stop com.aaa.windscribe.firewall_on\n";
                in << "launchctl unload " << filePath << "\n";
                in << "launchctl remove com.aaa.windscribe.firewall_on\n";
                in << "srm \"$0\"\n";
                //in << "rm " << filePath << "\n";
                in << "else\n";
                in << "echo \"File $FILE exists\"\n";
                in << "ipconfig waitall\n";
                in << "/sbin/pfctl -e -f \"" << pfConfFilePath << "\"\n";
                in << "fi\n";
                file.close();

                // set executable flag
                helper_->executeRootCommand("chmod +x \"" + pfBashScriptFile + "\"");
            }
        }

        // create plist
        QFile file(strTempFilePath);
        if (file.open(QIODevice::WriteOnly | QIODevice::Text))
        {
            file.resize(0);
            QTextStream in(&file);
            in << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
            in << "<!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n";
            in << "<plist version=\"1.0\">\n";
            in << "<dict>\n";
            in << "<key>Label</key>\n";
            in << "<string>com.aaa.windscribe.firewall_on</string>\n";

            in << "<key>ProgramArguments</key>\n";
            in << "<array>\n";
            in << "<string>/bin/bash</string>\n";
            in << "<string>" << pfBashScriptFile << "</string>\n";
            in << "</array>\n";

            in << "<key>StandardErrorPath</key>\n";
            in << "<string>/var/log/windscribe_pf.log</string>\n";
            in << "<key>StandardOutPath</key>\n";
            in << "<string>/var/log/windscribe_pf.log</string>\n";

            in << "<key>RunAtLoad</key>\n";
            in << "<true/>\n";
            in << "</dict>\n";
            in << "</plist>\n";

            file.close();

            helper_->executeRootCommand("cp " + strTempFilePath + " " + filePath);
            helper_->executeRootCommand("launchctl load -w " + filePath);
        }
        else
        {
            qCDebug(LOG_BASIC) << "Can't create plist file for startup firewall: " << filePath;
        }
    }
    else
    {
        qCDebug(LOG_BASIC) << "Execute command: "
                           << "launchctl unload " + Utils::cleanSensitiveInfo(filePath);
        helper_->executeRootCommand("launchctl unload " + filePath);
        qCDebug(LOG_BASIC) << "Execute command: " << "rm " + Utils::cleanSensitiveInfo(filePath);
        helper_->executeRootCommand("rm " + filePath);
        qCDebug(LOG_BASIC) << "Execute command: "
                           << "rm " + Utils::cleanSensitiveInfo(pfBashScriptFile);
        helper_->executeRootCommand("rm \"" + pfBashScriptFile + "\"");
    }
}
